// Copyright 2013, Belly, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//  Contributors:
//    Christian Vozar (christian@bellycard.com)

package amazonsns

import (
	"code.google.com/p/go-uuid/uuid"
	"encoding/json"
	"fmt"
	"github.com/mozilla-services/heka/message"
	. "github.com/mozilla-services/heka/pipeline"
	"io/ioutil"
	"net"
	"net/http"
	"os"
)

type AmazonSnsInput struct {
	conf     *AmazonSnsInputConfig
	listener net.Listener
	stopChan chan bool
	ir       InputRunner
	pConfig  *PipelineConfig
}

type AmazonSnsMessage struct {
	Type             string `json:",omitempty"`
	Hostname         string `json:",omitempty"`
	MessageId        string `json:",omitempty"`
	Token            string `json:",omitempty"`
	TopicArn         string `json:",omitempty"`
	SubscribeURL     string `json:",omitempty"`
	SubscriptionArn  string `json:",omitempty"`
	Subject          string `json:",omitempty"`
	Message          string `json:",omitempty"`
	Timestamp        string `json:",omitempty"`
	SignatureVersion string `json:",omitempty"`
	Signature        string `json:",omitempty"`
	SigningCertURL   string `json:",omitempty"`
	UnsubscribeURL   string `json:",omitempty"`
}

// Amazon Web Services SNS Input config struct
type AmazonSnsInputConfig struct {
	// TCP Address to listen to for SNS notifications.
	// Defaults to "0.0.0.0:8225".
	Address string
	// CertificateFile is the X509 cert file provided for HTTPS connectivity.
	CertificateFile string `toml:"certificate_file"`
	// KeyFile is the private X509 key for the CertificateFile.
	KeyFile string `toml:"key_file"`
	// Specifies whether or not notification data should be written to outgoing
	// message payloads, in JSON format as generated by Amazon SNS. If false data
	// will be written to outgoing message fields.
	// Defaults to true.
	EmitInPayload bool `toml:"emit_in_payload"`
}

// Default configuration for Amazon SNS Input
func (si *AmazonSnsInput) ConfigStruct() interface{} {
	return &AmazonSnsInputConfig{
		Address:          "0.0.0.0:8225",
		EmitInPayload:    true,
	}
}

// VerifyCertificateAuthority ensures the endpoint has a server certificate
// signed by a trusted Certificate Authority. Amazon SNS will only deliver
// messages to HTTPS endpoints that have a signed certificate from a
// trusted CA that Amazon SNS recognizes.
// http://docs.aws.amazon.com/sns/latest/dg/SendMessageToHttp.https.ca.html
func VerifyCertificateAuthority() bool {
	// authority: MD5 cert fingerprint
	authorities := map[string]string{
		"digicertassuredidrootca":             "87:CE:0B:7B:2A:0E:49:00:E1:58:71:9B:37:A8:93:72",
		"trustcenterclass2caii":               "CE:78:33:5C:59:78:01:6E:18:EA:B9:36:A0:B9:2E:23",
		"thawtepremiumserverca":               "A6:6B:60:90:23:9B:3F:2D:BB:98:6F:D6:A7:19:0D:46",
		"swisssignsilverg2ca":                 "E0:06:A1:C9:7D:CF:C9:FC:0D:C0:56:75:96:D8:62:13",
		"swisssignplatinumg2ca":               "C9:98:27:77:28:1E:3D:0E:15:3C:84:00:B8:85:03:E6",
		"equifaxsecureebusinessca1":           "64:9C:EF:2E:44:FC:C6:8F:52:07:D0:51:73:8F:CB:3D",
		"thawteserverca":                      "EE:FE:61:69:65:6E:F8:9C:C6:2A:F4:D7:2B:63:EF:A2",
		"utnuserfirstclientauthemailca":       "D7:34:3D:EF:1D:27:09:28:E1:31:02:5B:13:2B:DD:F7",
		"thawtepersonalfreemailca":            "53:4B:1D:17:58:58:1A:30:A1:90:F8:6E:5C:F2:CF:65",
		"utnuserfirsthardwareca":              "4C:56:41:E5:0D:BB:2B:E8:CA:A3:ED:18:08:AD:43:39",
		"entrustevca":                         "D6:A5:C3:ED:5D:DD:3E:00:C1:3D:87:92:1F:1D:3F:E4",
		"certumca":                            "2C:8F:9F:66:1D:18:90:B1:47:26:9D:8E:86:82:8C:A9",
		"addtrustclass1ca":                    "1E:42:95:02:33:92:6B:B9:5F:C0:7F:DA:D6:B2:4B:FC",
		"entrustrootcag2":                     "4B:E2:C9:91:96:65:0C:F4:0E:5A:93:92:A0:0A:FE:B2",
		"equifaxsecureca":                     "67:CB:9D:C0:13:24:8A:82:9B:B2:17:1E:D1:1B:EC:D4",
		"quovadisrootca3":                     "31:85:3C:62:94:97:63:B9:AA:FD:89:4E:AF:6F:E0:CF",
		"quovadisrootca2":                     "5E:39:7B:DD:F8:BA:EC:82:E9:AC:62:BA:0C:54:00:2B",
		"digicerthighassuranceevrootca":       "D4:74:DE:57:5C:39:B2:D3:9C:85:83:C5:C0:65:49:8A",
		"secomvalicertclass1ca":               "65:58:AB:15:AD:57:6C:1E:A8:A7:B5:69:AC:BF:FF:EB",
		"equifaxsecureglobalebusinessca1":     "8F:5D:77:06:27:C4:98:3C:5B:93:78:E7:D7:7D:9B:CC",
		"geotrustuniversalca":                 "92:65:58:8B:A2:1A:31:72:73:68:5C:B4:A5:7A:07:48",
		"thawteprimaryrootcag3":               "FB:1B:5D:43:8A:94:CD:44:C6:76:F2:43:4B:47:E7:31",
		"verisignclass3ca":                    "EF:5A:F1:33:EF:F1:CD:BB:51:02:EE:12:14:4B:96:C4",
		"deutschetelekomrootca2":              "74:01:4A:91:B1:08:C4:58:CE:47:CD:F0:DD:11:53:08",
		"utnuserfirstobjectca":                "A7:F2:E4:16:06:41:11:50:30:6B:9C:E3:B4:9C:B0:C9",
		"geotrustprimaryca":                   "02:26:C3:01:5E:08:30:37:43:A9:D0:7D:CF:37:E6:BF",
		"verisignclass1ca":                    "86:AC:DE:2B:C5:6D:C3:D9:8C:28:88:D3:8D:16:13:1E",
		"baltimorecodesigningca":              "90:F5:28:49:56:D1:5D:2C:B0:53:D4:4B:EF:6F:90:22",
		"baltimorecybertrustca":               "AC:B6:94:A5:9C:17:E0:D7:91:52:9B:B1:97:06:A6:E4",
		"starfieldclass2ca":                   "32:4A:4B:BB:C8:63:69:9B:BE:74:9A:C6:DD:1D:46:24",
		"camerfirmachamberscommerceca":        "B0:01:EE:14:D9:AF:29:18:94:76:8E:F1:69:33:2A:84",
		"ttelesecglobalrootclass3ca":          "CA:FB:40:A8:4E:39:92:8A:1D:FE:8E:2F:C4:27:EA:EF",
		"verisignclass3g5ca":                  "CB:17:E4:31:67:3E:E2:09:FE:45:57:93:F3:0A:FA:1C",
		"trustcenteruniversalcai":             "45:E1:A5:72:C5:A9:36:64:40:9E:F5:E4:58:84:67:8C",
		"ttelesecglobalrootclass2ca":          "2B:9B:9E:E4:7B:6C:1F:00:72:1A:CC:C1:77:79:DF:6A",
		"verisignclass3g3ca":                  "CD:68:B6:A7:C7:C4:CE:75:E0:1D:4F:57:44:61:92:09",
		"certumtrustednetworkca":              "D5:E9:81:40:C5:18:69:FC:46:2C:89:75:62:0F:AA:78",
		"certplusclass3pprimaryca":            "E1:4B:52:73:D7:1B:DB:93:30:E5:BD:E4:09:6E:BE:FB",
		"verisignclass3g2ca":                  "A2:33:9B:4C:74:78:73:D4:6C:E7:C1:F3:8D:CB:5C:E9",
		"globalsignr3ca":                      "C5:DF:B8:49:CA:05:13:55:EE:2D:BA:1A:C3:3E:B0:28",
		"utndatacorpsgcca":                    "B3:A5:3E:77:21:6D:AC:4A:C0:C9:FB:D5:41:3D:CA:06",
		"secomscrootca2":                      "6C:39:7D:A4:0E:55:59:B2:3F:D6:41:B1:12:50:DE:43",
		"secomscrootca1":                      "F1:BC:63:6A:54:E0:B5:27:F5:CD:E7:1A:E3:4D:6E:4A",
		"gtecybertrustglobalca":               "CA:3D:D3:68:F1:03:5C:D0:32:FA:B8:2B:59:E8:5A:DB",
		"verisignuniversalrootca":             "8E:AD:B5:01:AA:4D:81:E4:8C:1D:D1:E1:14:00:95:19",
		"trustcenterclass4caii":               "9D:FB:F9:AC:ED:89:33:22:F4:28:48:83:25:23:5B:E0",
		"globalsignr2ca":                      "94:14:77:7E:3E:5E:FD:8F:30:BD:41:B0:CF:E7:D0:30",
		"certplusclass2primaryca":             "88:2C:8C:52:B8:A2:3C:F3:F7:BB:03:EA:AE:AC:42:0B",
		"digicertglobalrootca":                "79:E4:A9:84:0D:7D:3A:96:D7:C0:4F:E2:43:4C:89:2E",
		"globalsignca":                        "3E:45:52:15:09:51:92:E1:B7:5D:37:9F:B1:87:29:8A",
		"thawteprimaryrootca":                 "8C:CA:DC:0B:22:CE:F5:BE:72:AC:41:1A:11:A8:D8:12",
		"geotrustglobalca":                    "F7:75:AB:29:FB:51:4E:B7:77:5E:FF:05:3C:99:8E:F5",
		"soneraclass2ca":                      "A3:EC:75:0F:2E:88:DF:FA:48:01:4E:0B:5C:48:6F:FB",
		"verisigntsaca":                       "7F:66:7A:71:D3:EB:69:78:20:9A:51:14:9D:83:DA:20",
		"quovadisrootca":                      "27:DE:36:FE:72:B7:00:03:00:9D:F4:F0:1E:6C:04:24",
		"soneraclass1ca":                      "33:B7:84:F5:5F:27:D7:68:27:DE:14:DE:12:2A:ED:6F",
		"valicertclass2ca":                    "A9:23:75:9B:BA:49:36:6E:31:C2:DB:F2:E7:66:BA:87",
		"comodoaaaca":                         "49:79:04:B0:EB:87:19:AC:47:B0:BC:11:51:9B:74:D0",
		"aolrootca2":                          "D6:ED:3C:CA:E2:66:0F:AF:10:43:0D:77:9B:04:09:BF",
		"keynectisrootca":                     "CC:4D:AE:FB:30:6B:D8:38:FE:50:EB:86:61:4B:D2:26",
		"addtrustqualifiedca":                 "27:EC:39:47:CD:DA:5A:AF:E2:9A:01:65:21:A9:4C:BB",
		"aolrootca1":                          "14:F1:08:AD:9D:FA:64:E2:89:E7:1C:CF:A8:AD:7D:5E",
		"verisignclass2g3ca":                  "F8:BE:C4:63:22:C9:A8:46:74:8B:B8:1D:1E:4A:2B:F6",
		"addtrustexternalca":                  "1D:35:54:04:85:78:B0:3F:42:42:4D:BF:20:73:0A:3F",
		"verisignclass2g2ca":                  "2D:BB:E5:25:D3:D1:65:82:3A:B7:0E:FA:E6:EB:E2:E1",
		"geotrustprimarycag3":                 "B5:E8:34:36:C9:10:44:58:48:70:6D:2E:83:D4:B8:05",
		"swisssigngoldg2ca":                   "24:77:D9:A8:91:D1:3B:FA:88:2D:C2:FF:F8:CD:33:93",
		"entrust2048ca":                       "EE:29:31:BC:32:7E:9A:E6:E8:B5:F7:51:B4:34:71:90",
		"gtecybertrust5ca":                    "7D:6C:86:E4:FC:4D:D1:0B:00:BA:22:BB:4E:7C:6A:8E",
		"camerfirmachambersignca":             "9E:80:FF:78:01:0C:2E:C1:36:BD:FE:96:90:6E:08:F3",
		"camerfirmachambersca":                "5E:80:9E:84:5A:0E:65:0B:17:02:F3:55:18:2A:3E:D7",
		"godaddyclass2ca":                     "91:DE:06:25:AB:DA:FD:32:17:0C:BB:25:17:2A:84:67",
		"entrustsslca":                        "DF:F2:80:73:CC:F1:E6:61:73:FC:F5:42:E9:C5:7C:EE",
		"verisignclass1g3ca":                  "B1:47:BC:18:57:D1:18:A0:78:2D:EC:71:E8:2A:95:73",
		"secomevrootca1":                      "22:2D:A6:01:EA:7C:0A:F7:F0:6C:56:43:3F:77:76:D3",
		"verisignclass1g2ca":                  "DB:23:3D:F9:69:FA:4B:B9:95:80:44:73:5E:7D:41:83",
		"godaddysecurecertificationauthority": "D5:DF:85:B7:9A:52:87:D1:8C:D5:0F:90:23:2D:B5:34",
	}

	return true
}

func (si *AmazonSnsInput) MessageHandler(w http.ResponseWriter, req *http.Request) {
	var m AmazonSnsMessage

	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		fmt.Errorf("[AmazonSnsInput] Read SNS message fail: %s\n", err.Error())
	}
	req.Body.Close()

	err = json.Unmarshal(body, &m)
	if err != nil {
		fmt.Errorf("[AmazonSnsInput] Decode JSON fail: %s\n", err.Error())
	}

	m.Hostname = req.Host

	switch m.Type {
	case "SubscriptionConfirmation":
		// Generate internal message for subscription notification
		pack := <-si.ir.InChan()
		pack.Decoded = true
		pack.Message.SetUuid(uuid.NewRandom())
		//pack.Message.SetTimestamp(m.Timestamp)
		pack.Message.SetType("amazon.sns.subscription")
		pack.Message.SetLogger("Amazon Simple Notification Service")
		pack.Message.SetHostname(m.Hostname)
		pack.Message.SetPid(int32(os.Getpid()))
		pack.Message.SetSeverity(int32(6))
		if si.conf.EmitInPayload {
			if contents, err := json.Marshal(m); err == nil {
				pack.Message.SetPayload(string(contents))
			} else {
				si.ir.LogError(fmt.Errorf("can't add payload: %s", err))
			}
		} else {
			if field, err := message.NewField("Type", m.Type, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("MessageId", m.MessageId, "UUID"); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("Token", m.Token, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("Message", m.Message, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("TopicArn", m.TopicArn, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("SubscribeURL", m.SubscribeURL, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
		}
		si.ir.Inject(pack)

		// Verify subscription with Amazon SNS
		resp, err := http.Get(m.SubscribeURL)
		// Consume HTTP response body
		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			si.ir.LogError(fmt.Errorf("[AmazonSnsInput] [%s]", err.Error()))
		}
		si.ir.LogMessage(fmt.Sprintf("[AmazonSnsInput Subscribed] Topic[%s]", m.TopicArn))
		resp.Body.Close()
	case "UnsubscribeConfirmation":
		// Handle unsubscribe logic
		si.ir.LogMessage(fmt.Sprintf("[AmazonSnsInput Unsubscribe] Topic[%s]", m.TopicArn))

		// Generate internal message for subscription notification
		pack := <-si.ir.InChan()
		pack.Decoded = true
		pack.Message.SetUuid(uuid.NewRandom())
		//pack.Message.SetTimestamp(m.Timestamp)
		pack.Message.SetType("amazon.sns.unsubscribe")
		pack.Message.SetLogger("Amazon Simple Notification Service")
		pack.Message.SetHostname(m.Hostname)
		pack.Message.SetPid(int32(os.Getpid()))
		pack.Message.SetSeverity(int32(6))
		if si.conf.EmitInPayload {
			if contents, err := json.Marshal(m); err == nil {
				pack.Message.SetPayload(string(contents))
			} else {
				si.ir.LogError(fmt.Errorf("can't add payload: %s", err))
			}
		} else {
			if field, err := message.NewField("Type", m.Type, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("MessageId", m.MessageId, "UUID"); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("Token", m.Token, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("Message", m.Message, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("TopicArn", m.TopicArn, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("SubscribeURL", m.SubscribeURL, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
		}
		si.ir.Inject(pack)
	default:
		pack := <-si.ir.InChan()
		pack.Decoded = true
		pack.Message.SetUuid(uuid.NewRandom())
		//pack.Message.SetTimestamp(m.Timestamp)
		pack.Message.SetType("amazon.sns.notification")
		pack.Message.SetLogger("Amazon Simple Notification Service")
		pack.Message.SetHostname(m.Hostname)
		pack.Message.SetPid(int32(os.Getpid()))
		pack.Message.SetSeverity(int32(6))
		if si.conf.EmitInPayload {
			if contents, err := json.Marshal(m); err == nil {
				pack.Message.SetPayload(string(contents))
			} else {
				si.ir.LogError(fmt.Errorf("can't add payload: %s", err))
			}
		} else {
			if field, err := message.NewField("Type", m.Type, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("MessageId", m.MessageId, "UUID"); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("Subject", m.Subject, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("Message", m.Message, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("TopicArn", m.TopicArn, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
		}
		si.ir.Inject(pack)
	}
}

func (si *AmazonSnsInput) Init(config interface{}) (err error) {
	si.stopChan = make(chan bool, 1)

	si.conf = config.(*AmazonSnsInputConfig)
	return nil
}

func (si *AmazonSnsInput) Run(ir InputRunner, h PluginHelper) (err error) {
	si.ir = ir
	si.pConfig = h.PipelineConfig()

	snsEndpointMux := http.NewServeMux()
	si.listener, err = net.Listen("tcp", si.conf.Address)
	if err != nil {
		return fmt.Errorf("[AmazonSnsInput] Listener [%s] start fail: %s\n", si.conf.Address, err.Error())
	}

	snsEndpointMux.HandleFunc("/", si.MessageHandler)
	err = http.Serve(si.listener, snsEndpointMux)
	if err != nil {
		return fmt.Errorf("[AmazonSnsInput] Serve fail: %s\n", err.Error())
	}

	for {
		select {
		case <-si.stopChan:
			return
		}
	}

	return nil
}

func (si *AmazonSnsInput) Stop() {
	si.listener.Close()
	close(si.stopChan)
}

func init() {
	RegisterPlugin("AmazonSnsInput", func() interface{} {
		return new(AmazonSnsInput)
	})
}
