// Copyright 2013, Belly, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//  Contributors:
//    Christian Vozar (christian@bellycard.com)

package amazonsns

import (
	"code.google.com/p/go-uuid/uuid"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"github.com/mozilla-services/heka/message"
	. "github.com/mozilla-services/heka/pipeline"
	"io/ioutil"
	"net"
	"net/http"
	"os"
)

type AmazonSnsInput struct {
	conf     *AmazonSnsInputConfig
	listener net.Listener
	name     string
	stopChan chan bool
	ir       InputRunner
	pConfig  *PipelineConfig
}

type SnsMessage struct {
	Type             string `json:",omitempty"`
	Hostname         string `json:",omitempty"`
	MessageId        string `json:",omitempty"`
	Token            string `json:",omitempty"`
	TopicArn         string `json:",omitempty"`
	SubscribeURL     string `json:",omitempty"`
	SubscriptionArn  string `json:",omitempty"`
	Subject          string `json:",omitempty"`
	Message          string `json:",omitempty"`
	Timestamp        string `json:",omitempty"`
	SignatureVersion string `json:",omitempty"`
	Signature        string `json:",omitempty"`
	SigningCertURL   string `json:",omitempty"`
	UnsubscribeURL   string `json:",omitempty"`
}

type SnsSubscriptionConfirmation struct {
	Result    string `xml:"SubscriptionArn"`
	RequestId string `xml:"RequestId"`
}

// Amazon Web Services SNS Input config struct
type AmazonSnsInputConfig struct {
	// TCP Address to listen to for SNS notifications.
	// Defaults to "0.0.0.0:8225".
	Address string
	// Verify the signatures of messages sent by SNS. Will add processing overhead.
	// Defaults to false.
	VerifySignatures bool `toml:"verify_signatures"`
	// Specifies whether or not notification data should be written to outgoing
	// message payloads, in JSON format as generated by Amazon SNS. If false data
	// will be written to outgoing message fields.
	// Defaults to true.
	EmitInPayload bool `toml:"emit_in_payload"`
}

func (si *AmazonSnsInput) ConfigStruct() interface{} {
	return &AmazonSnsInputConfig{
		Address:          "0.0.0.0:8225",
		VerifySignatures: false,
		EmitInPayload:    true,
	}
}

func (si *AmazonSnsInput) SetName(name string) {
	si.name = name
}

func (si *AmazonSnsInput) MessageHandler(w http.ResponseWriter, req *http.Request) {
	var (
		m SnsMessage
		s SnsSubscriptionConfirmation
	)

	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		fmt.Errorf("[AmazonSnsInput] Read SNS message fail: %s\n", err.Error())
	}
	req.Body.Close()

	err = json.Unmarshal(body, &m)
	if err != nil {
		fmt.Errorf("[AmazonSnsInput] Decode JSON fail: %s\n", err.Error())
	}

	m.Hostname = req.Host

	switch m.Type {
	case "SubscriptionConfirmation":
		// Generate internal message for subscription notification
		pack := <-si.ir.InChan()
		pack.Decoded = true
		pack.Message.SetUuid(uuid.NewRandom())
		//pack.Message.SetTimestamp(m.Timestamp)
		pack.Message.SetType("amazon.sns.subscription")
		pack.Message.SetLogger("Amazon Simple Notification Service")
		pack.Message.SetHostname(m.Hostname)
		pack.Message.SetPid(int32(os.Getpid()))
		pack.Message.SetSeverity(int32(6))
		if si.conf.EmitInPayload {
			if contents, err := json.Marshal(m); err == nil {
				pack.Message.SetPayload(string(contents))
			} else {
				si.ir.LogError(fmt.Errorf("can't add payload: %s", err))
			}
		} else {
			if field, err := message.NewField("Type", m.Type, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("MessageId", m.MessageId, "UUID"); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("Token", m.Token, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("Message", m.Message, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("TopicArn", m.TopicArn, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("SubscribeURL", m.SubscribeURL, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
		}
		si.ir.Inject(pack)

		// Verify subscription with Amazon SNS
		resp, err := http.Get(m.SubscribeURL)
		// Consume HTTP response body
		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			si.ir.LogError(fmt.Errorf("[AmazonSnsInput] [%s]", err.Error()))
		} else {
			err := xml.Unmarshal(body, &s)
			if err == nil {
				si.ir.LogMessage(fmt.Sprintf("[AmazonSnsInput Subscribed] Topic[%s] Id[%s] Result[%s]", m.TopicArn, s.RequestId, s.Result))
			}
		}
		resp.Body.Close()
	case "UnsubscribeConfirmation":
		// Handle unsubscribe logic
		si.ir.LogMessage(fmt.Sprintf("[AmazonSnsInput Unsubscribe] Topic[%s]", m.TopicArn))

		// Generate internal message for subscription notification
		pack := <-si.ir.InChan()
		pack.Decoded = true
		pack.Message.SetUuid(uuid.NewRandom())
		//pack.Message.SetTimestamp(m.Timestamp)
		pack.Message.SetType("amazon.sns.unsubscribe")
		pack.Message.SetLogger("Amazon Simple Notification Service")
		pack.Message.SetHostname(m.Hostname)
		pack.Message.SetPid(int32(os.Getpid()))
		pack.Message.SetSeverity(int32(6))
		if si.conf.EmitInPayload {
			if contents, err := json.Marshal(m); err == nil {
				pack.Message.SetPayload(string(contents))
			} else {
				si.ir.LogError(fmt.Errorf("can't add payload: %s", err))
			}
		} else {
			if field, err := message.NewField("Type", m.Type, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("MessageId", m.MessageId, "UUID"); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("Token", m.Token, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("Message", m.Message, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("TopicArn", m.TopicArn, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("SubscribeURL", m.SubscribeURL, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
		}
		si.ir.Inject(pack)
	default:
		pack := <-si.ir.InChan()
		pack.Decoded = true
		pack.Message.SetUuid(uuid.NewRandom())
		//pack.Message.SetTimestamp(m.Timestamp)
		pack.Message.SetType("amazon.sns.notification")
		pack.Message.SetLogger("Amazon Simple Notification Service")
		pack.Message.SetHostname(m.Hostname)
		pack.Message.SetPid(int32(os.Getpid()))
		pack.Message.SetSeverity(int32(6))
		if si.conf.EmitInPayload {
			if contents, err := json.Marshal(m); err == nil {
				pack.Message.SetPayload(string(contents))
			} else {
				si.ir.LogError(fmt.Errorf("can't add payload: %s", err))
			}
		} else {
			if field, err := message.NewField("Type", m.Type, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("MessageId", m.MessageId, "UUID"); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("Subject", m.Subject, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("Message", m.Message, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
			if field, err := message.NewField("TopicArn", m.TopicArn, ""); err == nil {
				pack.Message.AddField(field)
			} else {
				si.ir.LogError(fmt.Errorf("can't add field: %s", err))
			}
		}
		si.ir.Inject(pack)
	}
}

func (si *AmazonSnsInput) Init(config interface{}) (err error) {
	si.stopChan = make(chan bool, 1)

	si.conf = config.(*AmazonSnsInputConfig)
	return nil
}

func (si *AmazonSnsInput) Run(ir InputRunner, h PluginHelper) (err error) {
	si.ir = ir
	si.pConfig = h.PipelineConfig()

	snsEndpointMux := http.NewServeMux()
	si.listener, err = net.Listen("tcp", si.conf.Address)
	if err != nil {
		return fmt.Errorf("[AmazonSnsInput] Listener [%s] start fail: %s\n", si.conf.Address, err.Error())
	}

	snsEndpointMux.HandleFunc("/", si.MessageHandler)
	err = http.Serve(si.listener, snsEndpointMux)
	if err != nil {
		return fmt.Errorf("[AmazonSnsInput] Serve fail: %s\n", err.Error())
	}

	for {
		select {
		case <-si.stopChan:
			return
		}
	}

	return nil
}

func (si *AmazonSnsInput) Stop() {
	si.listener.Close()
	close(si.stopChan)
}

func init() {
	RegisterPlugin("AmazonSnsInput", func() interface{} {
		return new(AmazonSnsInput)
	})
}
